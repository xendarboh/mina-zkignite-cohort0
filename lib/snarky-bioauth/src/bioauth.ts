import {
  Bool,
  Field,
  Poseidon,
  PublicKey,
  Signature,
  Struct,
  UInt64,
} from 'snarkyjs';

export { BioAuthorizedMessage, ProvableBioAuth };

/**
 * A bio-authorized message signed and timestamped by an oracle.
 *
 * @class BioAuthorizedMessage
 */
class BioAuthorizedMessage extends Struct({
  payload: Field,
  timestamp: Field,
  bioAuthId: Field,
  signature: Signature,
}) {
  /**
   * Return a BioAuthorizedMessage created from JSON data.
   *
   * @param {{ payload: string; timestamp: string; bioAuthId: string; signature: any }} [data={}]
   * @return {*} {BioAuthorizedMessage}
   */
  static fromJSON(data: any) {
    return new BioAuthorizedMessage({
      payload: Field(data.data.payload),
      timestamp: Field(data.data.timestamp),
      bioAuthId: Field(data.data.bioAuthId),
      signature: Signature.fromJSON(data.signature),
    });
  }
}

/**
 * Collection of utility functions for crypto-biometric authorization in the circuit.
 *
 * @class ProvableBioAuth
 */
class ProvableBioAuth {
  /**
   * Verify a bio-authorized payload (signed oracle response) in circuit.
   *
   * @param {PublicKey} oraclePublicKey
   * @param {BioAuthorizedMessage} oracleMsg
   * @return {*}  {Bool}
   */
  static checkMessage(
    oraclePublicKey: PublicKey,
    oracleMsg: BioAuthorizedMessage
  ): Bool {
    // Check whether the signature is valid for the provided data
    const validSignature = oracleMsg.signature.verify(oraclePublicKey, [
      oracleMsg.payload,
      oracleMsg.timestamp,
      oracleMsg.bioAuthId,
    ]);

    // Check that the bioAuthId is not 0
    const validBioAuthId = oracleMsg.bioAuthId.equals(Field(0)).not();

    return validSignature.and(validBioAuthId);
  }

  /**
   * Verify a bio-authorized account (Mina PublicKey) in circuit.
   *
   * @param {PublicKey} oraclePublicKey
   * @param {BioAuthorizedMessage} oracleMsg
   * @param {PublicKey} userKey
   * @param {Signature} userSig
   * @return {*}  {Bool}
   */
  static checkAccount(
    oraclePublicKey: PublicKey,
    oracleMsg: BioAuthorizedMessage,
    userKey: PublicKey,
    userSig: Signature
  ): Bool {
    const validMessage = this.checkMessage(oraclePublicKey, oracleMsg);

    // Check that the user owns the user key
    const validSigUser = userSig.verify(userKey, userKey.toFields());

    // Check that the bioauthenticated payload was generated by the user
    const validSigHash = oracleMsg.payload.equals(
      Poseidon.hash(userSig.toFields())
    );

    return validMessage.and(validSigUser).and(validSigHash);
  }

  /**
   * Verify the TTL of the bio-authorized payload.
   *
   * NOTE: 2022-12-12 timestamp operations appear problematic
   *
   * @param {BioAuthorizedMessage} oracleMsg
   * @param {UInt64} currentTime
   * @param {UInt64} expireTime
   * @return {*}  {Bool}
   */
  static checkTTL(
    oracleMsg: BioAuthorizedMessage,
    currentTime: UInt64,
    expireTime: UInt64
  ): Bool {
    // Check that the current time is not before the oracle's timestamp
    // and not after the expiration time
    const then = UInt64.from(oracleMsg.timestamp);
    const validTimeLower = currentTime.gte(then);
    const validTimeUpper = currentTime.lte(expireTime);

    return validTimeLower.and(validTimeUpper);
  }
}
