import {
  Field,
  SmartContract,
  state,
  State,
  method,
  DeployArgs,
  Permissions,
  PublicKey,
  Signature,
  PrivateKey,
  Poseidon,
  UInt64,
} from 'snarkyjs';

// The public key of our trusted data provider
const ORACLE_PUBLIC_KEY =
  'B62qpxcmAq7DFDFk1wGrishcNTEVgwZaVbtsTFEc8CiARFt31oauHsu';

// The amount of time (in milliseconds) that the timestamped oracle signature
// is valid
export const BIOAUTH_TTL = 1000 * 60 * 10; // 10 minutes

export class BioAuthOracle extends SmartContract {
  // Define contract state
  @state(PublicKey) oraclePublicKey = State<PublicKey>();
  @state(UInt64) bioAuthTTL = State<UInt64>();

  // Define contract events
  events = {
    bioAuthorizedMessage: Field,
    bioAuthorizedAccount: PublicKey,
  };

  deploy(args: DeployArgs) {
    super.deploy(args);
    this.setPermissions({
      ...Permissions.default(),
      editState: Permissions.proofOrSignature(),
    });
  }

  @method init(zkappKey: PrivateKey) {
    super.init(zkappKey);

    // Initialize contract state
    this.oraclePublicKey.set(PublicKey.fromBase58(ORACLE_PUBLIC_KEY));
    this.bioAuthTTL.set(UInt64.from(BIOAUTH_TTL));

    // Specify that caller should include signature with tx instead of proof
    this.requireSignature();
  }

  // Verify an oracle response for a generic payload
  @method verifyMessage(
    payload: Field,
    timestamp: Field,
    bioAuthId: Field,
    signature: Signature
  ) {
    // Get the oracle public key from the contract state
    const oraclePublicKey = this.oraclePublicKey.get();
    this.oraclePublicKey.assertEquals(oraclePublicKey);

    // get the bioauth time-to-live from the contract state
    const bioAuthTTL = this.bioAuthTTL.get();
    this.bioAuthTTL.assertEquals(bioAuthTTL);

    // Evaluate whether the signature is valid for the provided data
    const validSignature = signature.verify(oraclePublicKey, [
      payload,
      timestamp,
      bioAuthId,
    ]);

    // Check that the signature is valid
    validSignature.assertTrue();

    // Check that the bioAuthId is not 0
    bioAuthId.equals(Field(0)).not().assertTrue();

    // Check that the current time is not before the oracle's timestamp
    // and not after the expiration time
    const then = UInt64.from(timestamp);
    this.network.timestamp.assertBetween(then, then.add(bioAuthTTL));

    // Emit an event containing the verified payload
    this.emitEvent('bioAuthorizedMessage', payload);
  }

  // Verify an oracle response where payload is a hashed signature from a given
  // PublicKey. This is used to associate a Mina PublicKey with an
  // authenticated biometric identifier.
  @method verifyAccount(
    userKey: PublicKey,
    userSig: Signature,
    payload: Field,
    timestamp: Field,
    bioAuthId: Field,
    signature: Signature
  ) {
    // Check that the user owns the user key
    const validSigUser = userSig.verify(userKey, userKey.toFields());
    validSigUser.assertTrue();

    // Check that the bioauthenticated payload was generated by the user
    payload.assertEquals(Poseidon.hash(userSig.toFields()));

    this.verifyMessage(payload, timestamp, bioAuthId, signature);

    // Emit an event containing the verified account
    this.emitEvent('bioAuthorizedAccount', userKey);
  }
}
